\documentclass{article}
% \usepackage{times}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{calc}
\usepackage{units}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subdepth}
\usepackage{cite}
\usepackage{url}
\usepackage{notoccite}
\usepackage{nag}
\title{Newtonian approximation in Causal Dynamical Triangulations}
\author{Adam Getchell}
\date{}
\begin{document}
\maketitle
\tableofcontents

\section{Motivation}

\subsection{Newton's Law of Gravitation from General Relativity}

Starting from the most general cylindrically symmetric (Weyl) metric \cite{synge_relativity}:

\begin{equation}
ds^{2}=e^{2\lambda}dt^{2}-e^{2\left(\nu-\lambda\right)}\left(dr^{2}+dz^{2}\right)-r^{2}e^{-2\lambda}d\phi^{2}
\end{equation}

\begin{equation}
g_{\mu\nu}=\left(\begin{array}{cccc}
e^{2\lambda}dt^{2} & 0 & 0 & 0\\
0 & -e^{2\left(\nu-\lambda\right)}dr^{2} & 0 & 0\\
0 & 0 & -e^{2\left(\nu-\lambda\right)}dz^{2} & 0\\
0 & 0 & 0 & -\frac{r^{2}}{e^{2\lambda}}d\phi^{2}
\end{array}\right)\label{eq:general-axisymmetric-static-matrix-metric}
\end{equation}
The definition of the Christoffel connection is: \cite{carroll2003spacetime} 
\begin{equation}
\Gamma_{\mu\nu}^{\lambda}=\frac{1}{2}g^{\lambda\sigma}\left(\partial_{\mu}g_{\nu\sigma}+\partial_{\nu}g_{\sigma\mu}-\partial_{\sigma}g_{\mu\nu}\right)
\end{equation}
With the assumption of zero torsion:
\begin{equation}
\Gamma_{\mu\nu}^{\lambda}=\Gamma_{\nu\mu}^{\lambda}
\end{equation}
The non-zero Christoffel connections are:
\begin{equation}
\begin{array}{l}
\Gamma^{t}_{tr}=\partial_{r}\lambda\\
\Gamma^{t}_{tz}=\partial_{z}\lambda\\
\Gamma^{r}_{tt}=e^{4\lambda-2\nu}\partial_{r}\lambda\\
\Gamma^{r}_{rr}=\partial_{r}\nu-\partial_{r}\lambda\\
\Gamma^{r}_{rz}=\partial_{z}\nu-\partial_{z}\lambda\\
\Gamma^{r}_{zz}=\partial_{z}\lambda-\partial_{z}\nu\\
\Gamma^{r}_{\phi\phi}=re^{-2\nu}\left(r\partial_{r}\lambda-1\right)\\
\Gamma^{z}_{tt}=e^{4\lambda-2\nu}\partial_{z}\lambda\\
\Gamma^{z}_{rr}=\partial_{z}\lambda-\partial_{z}\nu\\
\Gamma^{z}_{rz}=\partial_{r}\nu-\partial_{r}\lambda\\ 
\Gamma^{z}_{zz}=\partial_{r}\nu-\partial_{r}\lambda\\
\Gamma^{z}_{\phi\phi}=r^{2}e^{-2\nu}\partial_{z}\lambda\\
\Gamma^{\phi}_{r\phi}=\frac{1}{r}-\partial_{r}\lambda\\
\Gamma^{\phi}_{z\phi}=-\partial_{z}\lambda\\
\end{array}
\end{equation}
The components of the Riemann tensor are given by:
\begin{equation}
R_{\sigma\mu\nu}^{\rho}=\partial_{\mu}\Gamma_{\nu\sigma}^{\rho}-\partial_{\nu}\Gamma_{\mu\sigma}^{\rho}+\Gamma_{\mu\lambda}^{\rho}\Gamma_{\nu\sigma}^{\lambda}-\Gamma_{\nu\lambda}^{\rho}\Gamma_{\mu\sigma}^{\lambda}
\end{equation}
Using the properties of the Riemann tensor:
\begin{equation}
\begin{array}{l}
R_{\rho\sigma\mu\nu}=-R_{\rho\sigma\nu\mu}\\
R_{\rho\sigma\mu\nu}=-R_{\sigma\rho\mu\nu}\\
R_{\rho\sigma\mu\nu}=R_{\mu\nu\rho\sigma}\\
R_{\rho[\sigma\mu\nu]}=0\\
\end{array}
\end{equation}
The non-zero components of the Riemann tensor are:
\begin{equation}
\begin{array}{l}
R^{t}_{rtr}=-\partial^{2}_{r}\lambda+\left(\partial_{z}\lambda\right)^{2}-2\left(\partial_{r}\lambda\right)^{2}+\partial_{r}\lambda\partial_{r}\nu-\partial_{z}\lambda\partial_{z}\nu\\
R^{t}_{rtz}=-\partial_{r}\partial_{z}\lambda-3\partial_{r}\lambda\partial_{z}\lambda+\partial_{r}\lambda\partial_{z}\nu+\partial_{r}\nu\partial_{z}\lambda\\
R^{t}_{ztz}=-\partial^{2}_{z}\lambda-2\left(\partial_{z}\lambda\right)^{2}+\left(\partial_{r}\lambda\right)^{2}-\partial_{r}\lambda\partial_{r}\nu+\partial_{z}\lambda\partial_{z}\nu\\
R^{t}_{\phi t\phi}=re^{-2\nu}\left(r\left(\partial_{r}\lambda\right)^{2}-\partial_{r}\lambda+r\left(\partial_{z}\lambda\right)^{2}\right)\\
R^{r}_{zrz}=\partial^{2}_{r}\lambda-\partial^{2}_{r}\nu+\partial^{2}_{z}\lambda-\partial^{2}_{z}\nu\\
R^{z}_{\phi z\phi}=re^{-2\nu}\left(r\partial^{2}_{z}\lambda-r\partial_{z}\lambda\partial_{z}\nu+r\partial_{r}\lambda\partial_{r}\nu-r\left(\partial_{r}\lambda\right)^{2}+\partial_{r}\lambda-\partial_{r}\nu\right)\\
R^{z}_{\phi\phi r}=re^{-2\nu}\left(-r\partial_{r}\partial_{z}\lambda+r\partial_{r}\nu\partial_{z}\lambda-r\partial_{r}\lambda\partial_{z}\lambda+r\partial_{r}\lambda\partial_{z}\nu-\partial_{z}\nu\right)\\
R^{\phi}_{r\phi r}=\partial^{2}_{r}\lambda+\frac{1}{r}\partial_{r}\nu-\partial_{r}\lambda\partial_{r}\nu-\left(\partial_{z}\lambda\right)^{2}+\partial_{z}\lambda\partial_{z}\nu+\frac{1}{r}\partial_{r}\lambda\\
\end{array}
\end{equation}
The Ricci tensor is given by:
\begin{equation}
R_{\mu\nu}=R_{\mu\lambda\nu}^{\lambda}
\end{equation}
The non-zero components of the Ricci tensor are:
\begin{equation}
\begin{array}{l}
R_{tt}=\frac{e^{4\lambda-2\nu}}{r}\left(r\partial^{2}_{r}\lambda+r\partial^{2}_{z}\lambda+\partial_{r}\lambda\right)\\
R_{rr}=\partial^{2}_{r}\lambda-\partial^{2}_{r}\nu+\partial^{2}_{z}\lambda-\partial^{2}_{z}\nu-2\left(\partial_{r}\lambda\right)^{2}+\frac{1}{r}\partial_{r}\lambda+\frac{1}{r}\partial_{r}\nu\\
R_{rz}=\frac{1}{r}\partial_{z}\nu-2\partial_{r}\lambda\partial_{z}\lambda\\
R_{zz}=\partial^{2}_{r}\lambda-\partial^{2}_{r}\nu+\partial^{2}_{z}\lambda-\partial^{2}_{z}\nu-2\left(\partial_{z}\lambda\right)^{2}+\frac{1}{r}\partial_{r}\lambda-\frac{1}{r}\partial_{r}\nu\\
R_{\phi\phi}=re^{-2\nu}\left(r\partial^{2}_{r}\lambda+r\partial^{2}_{z}\lambda+\partial_{r}\lambda\right)
\end{array}\label{eq:ricci-tensor-components}
\end{equation}
Einstein's equation in a vacuum is:
\begin{equation}
R_{\mu\nu}=0\label{eq:vacuum-solutions}
\end{equation}
Applying this complete set of relations to Equation (\ref{eq:ricci-tensor-components}) gives the following:
\begin{equation}
\partial^{2}_{r}\lambda+\frac{1}{r}\partial_{r}\lambda+\partial^{2}_{z}\lambda=0\label{eq:partial-laplace}
\end{equation}
Writing Equation (\ref{eq:partial-laplace}) explicitly gives Laplace's equation in cylindrical coordinates:
\begin{equation}
\frac{\partial^{2}\lambda}{\partial r^{2}}+\frac{1}{r}\frac{\partial\lambda}{\partial r}+\frac{\partial^{2}\lambda}{\partial z^{2}}=0
\end{equation}
\subsection{Additional issues}



\section{Applications to Causal Dynamical Triangulations}

\subsection{Preliminaries}

A simplex is a generalization of a triangle to arbitrary dimension. For example, a 2-simplex is a triangle, a 3-simplex is a tetrahedron, and a 4-simplex is a pentachoron. Topologically, an n-simplex is equivalent to an n-ball; that is, an n-dimensional manifold with boundary.

An n-dimensional simplex has $n+1$ points or \emph{vertices}. A convex hull, or minimal convex set of these points is the \emph{m-face} of the \emph{n-simplex}. Thus, a vertex is a \emph{0-face}, and an edge between two vertices is the \emph{1-face}. We can extend this notation to \emph{2-faces} (triangles), \emph{3-faces} (tetrahedrons), \emph{4-faces} (pentachorons). We will not, at present, consider simplices of dimension higher than $n=4$, but this generalization gives us a useful way to reason about higher dimensional spaces.

The number of \emph{m-faces} on our \emph{n-simplex} is given by the binomial coefficient as:

\begin{equation}
\left(\begin{array}{c}n+1\\m+1\end{array}\right)
\end{equation}

Thus, our pentachoron has 5 vertices, 10 edges, 10 faces (triangles), 5 cells (tetrahedrons), and 1 4-face, itself.

A given face can be shared by another simplex. By requiring that \cite{weisstein1}:

\begin{itemize}
\item Every face of a simplex \emph{K} is in \emph{K}, and
\item The intersection of any two simplices of K is a face of each of them
\end{itemize}

We build up a useful structure called a simplicial complex. Informally, this is a space with a triangulation. Formally, simplicial complexes have only been proven for spaces of dimension $d\le3$. A simplicial complex has a well-defined homology (simplicial homology) which is easy to compute.

\subsection{Code Correctness}

Implementing CDT in computer code is non-trivial. As a first significant step, an independent implementation of CDT has given similar results to the original work \cite{kommu2011}. We would like to build on Kommu's implementation using Literate Programming \cite{knuth_literate_1984} coupled with Test Driven Development specific to the programming language used \cite{rathore_clojure_2011}. This provides for the codebase to be better understood by researchers wishing to replicate results or expand the capabilities of the code, and provides inherent integrity checks apart from "it produced what we expected". Such methodology will be critical to expanding the performance of the code by using such techniques as parallel processing and highly optimized algorithms. The adage of "Make it work, make it right, make it fast" applies.

The first building block of the code are the simplexes themselves. Using the known properties of simplicial complexes, we can provide for a series of checks that validate that simplices are being constructed correctly. Such checks will provide useful test cases when the underlying implementation of simplex data structures and moves are changed.

\subsection{Data structures}

\subsection{Issues}

\begin{itemize}
\item Extrinsic Curvature \emph{(To Do)}
\item Imposing conditions of separation
\item Checking that separation >\textcompwordmark{}> Schwarzschild radius
\item Imposing cylindrical symmetry
\end{itemize}

\subsection{CDT Algorithm}

\emph{(To Do: insert graphics)}

\begin{itemize}
\item {[}(2,8): (1,4) + (4,1) $\rightarrow$8 simplices{]} + inverse = +2
moves
\item {[}(4,6): ()+()+()+()$\rightarrow$6 simplices{]} + inverse = +2 moves
\item {[}(2,4): two varieties of ()+()$\rightarrow$4 simplices{]}, self-inverse
= +2 moves
\item {[}(3,3): two varieties of ()+()+()$\rightarrow$3 simplices{]} +
inverse = +4 moves\end{itemize}
\begin{description}
\item [{10}] moves in all (\emph{Check!)}
\end{description}

\includegraphics[scale=0.35]{Initialization}

Dijkstra's Algorithm \cite{cormen2001introduction}


Solves single-source shortest-path problems on weighted, directed
graph G=(V,E) of non-negative edge lengths

\begin{itemize}
\item Greedy algorithm
\item Proven to be correct
\item Complexity

\begin{itemize}
\item $O(V^{2})$ naively using adjacency list
\item $O(E\lg V)$ using priority queue iff all vertices reachable from
source
\item $O(V\lg V+E)$ using Fibonacci heap (more relaxation calls than extract-min
calls)
\end{itemize}
\item Issue: confine edge length algorithm to particular time-slice
\item Solution: Store Fibonacci heap of simplices per time-slice

\begin{itemize}
\item Each simplex has 5 neighbors, so more compact than adjacency matrix
\end{itemize}

\begin{itemize}
\item How to deal with moves affecting original ``mass'' simplices
\item How to create a 4d cylinder of height z=d
\item Verify Markov chain for initialization is ergodic
\item Calculate <d>
\end{itemize}
\end{itemize}

\section{Summary}
\begin{itemize}
\item Insert mass equivalence via extrinsic curvature
\item Insert strut by enforcing separation distance
\item Filter moves which alter separation distance via Markov chain
\item Outlook

\begin{itemize}
\item Write code!
\item Check Extrinsic Curvature
\item Compare results
\end{itemize}
\end{itemize}

\bibliographystyle{ieeetr}
\bibliography{cdt-newtonian-limit-biblio}


\end{document}
